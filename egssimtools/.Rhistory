edges <- edges %>% dplyr::mutate(trait = as.numeric(factor(trait)) - 1)
edges <- edges %>% dplyr::rename(from = edges0, to = edges1, weight = weights)
edges <- edges %>% dplyr::mutate(from = from + 1, to = to + 1) # C++ indexing
edges <- edges %>% dplyr::select(from, to, weight, trait)
# Return a tidygraph object suitable for plotting networks
network <- tidygraph::tbl_graph(nodes = nodes, edges = edges)
if (as_list) network <- as.list(network)
return (network)
}
read_arch_network(root, as_df = FALSE) %>% as.list
read_arch_network(root, as_list = FALSE) %>% as.list
read_arch_network(root, as_list = FALSE) %>% as.list %>% str
roxygen2::roxygenize()
library(egssimtools)
read_arch_network(root, as_list = FALSE)
read_arch_network(root, as_list = TRUE)
data <- read_data(root, c("time", "network_corbreed"), dupl = c(nedges, 1))
arch <- read_arch_network(root, as_list = TRUE)$edges
data %>% right_join(edges)
data %>% right_join(arch)
data
cbind(data, arch)
bind_cols(data, arch)
bind(data, arch)
join(data, arch)
cbind(data, arch)
tibble(cbind(data, arch))
nedges <- guess_nedges(root)
data <- read_data(
root,
c("time", variables),
dupl = c(nedges, rep(1, length(variables)))
)
arch <- read_arch_network(root, as_list = TRUE)$edges
data <- tibble(cbind(data, arch))
variables <- c("network_corbreed")
nedges <- guess_nedges(root)
data <- read_data(
root,
c("time", variables),
dupl = c(nedges, rep(1, length(variables)))
)
arch <- read_arch_network(root, as_list = TRUE)$edges
data <- tibble(cbind(data, arch))
data
data$edge <- rep(seq(nedges), nrow(data) / nedges)
arch <- read_arch_network(root, as_list = TRUE)$edges
arch$edge <- data$edge
data$edge
length(data$edge)
nrow(arch$edge)
nrow(arch)
arch <- read_arch_network(root, as_list = TRUE)$edges
ntimes <- nrow(data) / nedges
ntimes
map_dfr(seq(ntimes), ~ arch)
data
arch <- map_dfr(seq(ntimes), ~ arch)
data %>% right_join(arch)
root <- "data"
root <- "data"
roots <- fetch_dirs(root, "example", level = 1)
read_data(roots[1], "time")
read_data(roots[1], c("time", "EI"))
read_sim(roots[1], "EI")
read_pop(roots[1], "individual_trait", by = 3)
read_genome(roots[1], "genome_Fst")
read_network(roots[1], "network_corbreed")
roxygen2::roxygenize()
library(egssimtools)
read_network(roots[1], "network_corbreed")
read_genome(roots[1], "genome_Fst")
read_network(roots[1], "network_corbreed")
guess_nedges(roots[1])
#' Read edge-specific data through time
#'
#' Wrapper around `read_data` to read edge-wise data
#'
#' @param folder Path to the folder
#' @param variables What variables to read (`time` is included by default)
#' @param parnames,combine,as_numeric,parfile Parameters
#' for `read_data`
#' @param architecture Whether to attach genetic architecture data
#' @param archfile Optional name of the genetic architecture file
#' @param nedges Number of edges (automatically guessed if unspecified)
#'
#' @details The file `time.dat` must be present
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data/example_1"
#'
#' # Read Fst throughout the genome
#' read_edges(root, "network_corbreed")
#'
#' # Read multiple metrics and attach architecture
#' variables <- paste0("network_", c("corbreed", "corfreq"))
#' read_network(root, variables, architecture = TRUE)
#'
#' }
#'
#' @export
read_network <- function(
folder,
variables,
parnames = NULL,
combine = FALSE,
as_numeric = NULL,
architecture = FALSE,
archfile = "architecture.txt",
parfile = "paramlog.txt",
nedges = NULL
) {
if (is.null(nedges)) nedges <- guess_nedges(root, variables[1])
data <- read_data(
root,
c("time", variables),
dupl = c(nedges, rep(1, length(variables))),
parnames = parnames,
combine = combine,
as_numeric = as_numeric,
parfile = parfile
)
data$edge <- rep(seq(nedges), nrow(data) / nedges)
if (architecture) {
ntimes <- nrow(data) / nedges
arch <- read_arch_network(root, archfile, as_list = TRUE)$edges
arch <- purrr::map_dfr(seq(ntimes), ~ arch)
data <- data %>% dplyr::right_join(arch)
}
return(data)
}
read_network(roots[1], "network_corbreed")
guess_nedges(roots[1])
guess_nrows(roots[1], "network_corbreed")
read_network(roots[1], "network_corbreed")
read_network(roots[1], "network_corbreed", nedges = 3000)
roots
read_binary(file.path(roots[1], "time.dat"))
read_binary(file.path(roots[1], "network_corbreed.dat"))
#' Read edge-specific data through time
#'
#' Wrapper around `read_data` to read edge-wise data
#'
#' @param folder Path to the folder
#' @param variables What variables to read (`time` is included by default)
#' @param parnames,combine,as_numeric,parfile Parameters
#' for `read_data`
#' @param architecture Whether to attach genetic architecture data
#' @param archfile Optional name of the genetic architecture file
#' @param nedges Number of edges (automatically guessed if unspecified)
#'
#' @details The file `time.dat` must be present
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data/example_1"
#'
#' # Read Fst throughout the genome
#' read_edges(root, "network_corbreed")
#'
#' # Read multiple metrics and attach architecture
#' variables <- paste0("network_", c("corbreed", "corfreq"))
#' read_network(root, variables, architecture = TRUE)
#'
#' }
#'
#' @export
read_network <- function(
folder,
variables,
parnames = NULL,
combine = FALSE,
as_numeric = NULL,
architecture = FALSE,
archfile = "architecture.txt",
parfile = "paramlog.txt",
nedges = NULL
) {
if (is.null(nedges)) nedges <- guess_nedges(folder, variables[1])
data <- read_data(
folder,
c("time", variables),
dupl = c(nedges, rep(1, length(variables))),
parnames = parnames,
combine = combine,
as_numeric = as_numeric,
parfile = parfile
)
data$edge <- rep(seq(nedges), nrow(data) / nedges)
if (architecture) {
ntimes <- nrow(data) / nedges
arch <- read_arch_network(folder, archfile, as_list = TRUE)$edges
arch <- purrr::map_dfr(seq(ntimes), ~ arch)
data <- data %>% dplyr::right_join(arch)
}
return(data)
}
read_network(roots[1], "network_corbreed", nedges = 3000)
read_network(roots[1], "network_corbreed")
read_genome(roots[1], "genome_Fst", architecture = TRUE)
#' Read locus-specific data through time
#'
#' Wrapper around `read_data` to read locus-wise data
#'
#' @param folder Path to the folder
#' @param variables What variables to read (`time` is included by default)
#' @param parnames,combine,as_numeric,parfile Parameters
#' for `read_data`
#' @param architecture Whether to attach genetic architecture data
#' @param archfile Optional name of the genetic architecture file
#' @param nloci Number of loci (automatically guessed if unspecified)
#'
#' @details The file `time.dat` must be present
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data/example_1"
#'
#' # Read Fst throughout the genome
#' read_genome(root, "genome_Fst")
#'
#' # Read multiple metrics and attach architecture
#' read_genome(root, c("genome_Fst", "genome_Cst"), architecture = TRUE)
#'
#' }
#'
#' @export
read_genome <- function(
folder,
variables,
parnames = NULL,
combine = FALSE,
as_numeric = NULL,
architecture = FALSE,
archfile = "architecture.txt",
parfile = "paramlog.txt",
nloci = NULL
) {
if (is.null(nloci)) nloci <- guess_nloci(folder, variables[1])
data <- read_data(
folder,
c("time", variables),
dupl = c(nloci, rep(1, length(variables))),
parnames = parnames,
combine = combine,
as_numeric = as_numeric,
parfile = parfile
)
data$locus <- rep(seq(nloci), nrow(data) / nloci)
if (architecture) {
ntimes <- nrow(data) / nloci
arch <- read_arch_genome(folder, archfile)
arch <- purrr::map_dfr(seq(ntimes), ~ arch)
data <- data %>% dplyr::right_join(arch)
}
return(data)
}
library(egssimtools)
read_genome(roots[1], "genome_Fst", architecture = TRUE)
read_network(roots[1], "network_corbreed", architecture = TRUE)
read_arch_network(roots[1])
read_arch_network(roots[1], as_list = TRUE)
read_arch_network(roots[1], as_list = TRUE)$edges
#' Read gene network architecture
#'
#' Reads a genetic architecture and stores it into a `tbl_graph` object
#'
#' @param folder Path to the simulation
#' @param filename Optional architecture file name
#' @param as_list Whether to return the output at a list of two tibbles
#' instead of a `tbl_graph`.
#'
#' @return A `tbl_graph` object (useful for plotting using the `ggraph`
#' package), or a list of data frames if applicable
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data/example_1"
#'
#' read_arch_network(root)
#'
#' }
#'
#' @export
read_arch_network <- function(
folder,
filename = "architecture.txt",
as_list = FALSE
) {
# Read the nodes
nodes <- read_arch_genome(folder, filename)
# Read the edges
edges <- read_arch(folder, filename)
edges <- purrr::map_dfr(
edges$networks, ~ do.call("data.frame", .x), .id = "trait"
)
edges <- edges %>% dplyr::mutate(trait = as.numeric(factor(trait)) - 1)
edges <- edges %>% dplyr::rename(from = edges0, to = edges1, weight = weights)
edges <- edges %>% dplyr::mutate(from = from + 1, to = to + 1) # C++ indexing
edges <- edges %>% dplyr::mutate(edge = seq(nrow(edges)))
edges <- edges %>% dplyr::select(from, to, weight, trait, edge)
# Return a tidygraph object suitable for plotting networks
network <- tidygraph::tbl_graph(nodes = nodes, edges = edges)
if (as_list) network <- as.list(network)
return (network)
}
read_arch_network(roots[1], as_list = TRUE)$edges
library(egssimtools)
read_network(roots[1], "network_corbreed", architecture = TRUE)
roots <- fetch_dirs(root, "example", level = 1)
roots <- check_extant(roots)
roots <- find_extant(roots)
roots
#' Wrapper around data readers
#'
#' This function works as an alias for the `read_*` family of functions
#'
#' @param root Path to a simulation folder
#' @param type Which `read_*` function to call, either of `data`, `sim`, `pop`,
#' `genome` or `network`
#' @param ... Parameters to be passed to the reading function
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' root <- "data/example_1"
#'
#' read_this(root, "sim", variables = "EI")
#'
#' }
#'
#' @seealso `read_data`, `read_sim`, `read_pop`, `read_genome`, `read_network`
#'
#' @export
read_this <- function(root, type = "data", ...) {
if (type == "data") {
read_data(root, ...)
} else if (type == "sim") {
read_sim(root, ...)
} else if (type == "pop") {
read_pop(root, ...)
} else if (type == "genome") {
read_genome(root, ...)
} else if (type == "network") {
read_network(root, ...)
} else {
stop("invalid value for type argument")
}
}
root <- "data/example_1"
read_this(root, "sim", variables = "EI")
#' Collect data from across simulations
#'
#' Collect specified variables and parameters from across multiple simulation
#' folders
#'
#' @param root One of multiple paths to simulation folders or folders into
#' which to recurse to look for simulation folders.
#' @param check_extant Whether to check for non-extinct and non-crashed
#'  simulation folders
#' @param pattern Optional pattern to look for if simulation folders are
#' searched by recursion
#' @param level Level of recursion. Defaults to 0 for no recursion (then assumes
#' that `root` is a vector of simulation folder paths).
#' @param type The `type` argument of `read_this`
#' @param id_column Optional name of the simulation identifier column
#' @param ... Parameters to be passed to `read_this`
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data"
#'
#' # Collect simulation data with some parameters
#' collect_data(
#'   root, c("time", "EI"), pattern = "example", level = 1,
#'   check_extant = FALSE, parnames = c("ecosel", "hsymmetry")
#' )
#'
#' }
#'
#' @export
collect_data <- function(
root,
check_extant = TRUE,
pattern = "sim_",
level = 0,
type = "data",
id_column = "sim",
...
) {
# Fetch simulation folders
if (level > 0) root <- fetch_dirs(root, pattern = pattern, level = level)
# Find extant simulations if needed
if (check_extant) root <- find_extant(root)
# Read the data and combine
data <- purrr::map_dfr(root, read_this, type, ..., .id = id_column)
return(data)
}
root <- "data"
collect_data(
root, c("time", "EI"), pattern = "example", level = 1,
check_extant = FALSE, parnames = c("ecosel", "hsymmetry")
)
read_this(root, "data", variables = c("time", "EI"))
root <- "data/example_1"
read_this(root, "sim", variables = "EI")
read_this(root, "data", variables = c("time", "EI"))
root <- "data"
collect_data(
root, variables = c("time", "EI"), pattern = "example", level = 1,
check_extant = FALSE, parnames = c("ecosel", "hsymmetry")
)
#' Collect data from across simulations
#'
#' Collect specified variables and parameters from across multiple simulation
#' folders
#'
#' @param root One of multiple paths to simulation folders or folders into
#' which to recurse to look for simulation folders.
#' @param check_extant Whether to check for non-extinct and non-crashed
#'  simulation folders
#' @param pattern Optional pattern to look for if simulation folders are
#' searched by recursion
#' @param level Level of recursion. Defaults to 0 for no recursion (then assumes
#' that `root` is a vector of simulation folder paths).
#' @param type The `type` argument of `read_this`
#' @param id_column Optional name of the simulation identifier column
#' @param ... Parameters to be passed to `read_this`
#'
#' @return A tibble
#'
#' @examples
#'
#' \dontrun{
#'
#' # Location of the simulation folder
#' root <- "data"
#'
#' # Collect simulation data with some parameters
#' collect_data(
#'   root, variables = c("time", "EI"), pattern = "example", level = 1,
#'   parnames = c("ecosel", "hsymmetry")
#' )
#'
#' collect_data(
#'   root, variables = "genome_Fst", pattern = "example", level = 1,
#'   parnames = c("ecosel", "hsymmetry"), architecture = TRUE, type = "genome"
#' )
#'
#' }
#'
#' @export
collect_data <- function(
root,
check_extant = FALSE,
pattern = "sim_",
level = 0,
type = "data",
id_column = "sim",
...
) {
# Fetch simulation folders
if (level > 0) root <- fetch_dirs(root, pattern = pattern, level = level)
# Find extant simulations if needed
if (check_extant) root <- find_extant(root)
# Read the data and combine
data <- purrr::map_dfr(root, read_this, type, ..., .id = id_column)
return(data)
}
root <- "data"
# Collect simulation data with some parameters
collect_data(
root, variables = c("time", "EI"), pattern = "example", level = 1,
parnames = c("ecosel", "hsymmetry")
)
collect_data(
root, variables = "genome_Fst", pattern = "example", level = 1,
parnames = c("ecosel", "hsymmetry"), architecture = TRUE, type = "genome"
)
collect_data(
root, variables = "network_corbreed", pattern = "example", level = 1,
parnames = c("ecosel", "hsymmetry"), architecture = TRUE, type = "network"
)
roxygen2::roxygenize()
library(egssimtools)
