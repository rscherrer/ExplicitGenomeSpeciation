/*==================================================================================================================================
                                                        architecture.cpp
 ====================================================================================================================================
 
 C++-code accompanying:
 
 (ms. in prep).
 
 Written by:
 G. Sander van Doorn
 Centre for Ecological and Evolutionary Studies - Theoretical Biology Group
 University of Groningen
 the Netherlands
 
 Program version
 xx/xx/2018	:
 
 Instructions for compiling and running the program
 
	Versions of this program were compiled and run on Windows and Mac, using Microsoft Visual C++
	2010 and XCode, respectively. The code is written in standard C++ and should be compatible with
	other compilers.
 
 =================================================================================================================================*/

#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include "individual.h"
#include "random.h"

// parameters of the allelic and interaction effect size distributions
const double alphaAdditiveShared = 1.5;
const double alphaAdditiveRandom = 0.5;
const double alphaInteractionShared = 0.5;
const double alphaInteractionRandom = 1.0;

/*=======================================================================================================
                static members of class Individual
 ========================================================================================================*/

std::array<double, nChromosomes - 1u> Individual::chromosomeSize;
std::array<Individual::Character, nLoci> Individual::characterLocus;
std::array<std::set<size_t>, nCharacter> Individual::vertices;
std::array<double, nCharacter> Individual::varD, Individual::covL, Individual::F_st, Individual::P_st, Individual::G_st, Individual::Q_st, Individual::C_st;
std::array<std::array<double, 3u>, nCharacter> Individual::avgG,
Individual::varP, Individual::varG,Individual::varA, Individual::varI;

/*=======================================================================================================
                static functions of class Individual
 ========================================================================================================*/

typedef std::pair<size_t, size_t> Edge;

bool edgeCompare (const Edge &x, const Edge &y) {
    if(x.first == y.first) return (x.second < y.second);
    else return (x.first < y.first);
}

void preferentialAttachmentNetwork(const size_t n, size_t e, const double exponent, std::vector<Edge> &edges)
// creates a random network generated by a (non)linear preferential attachment model
// the network is guaranteed to be connected as has no self-loops or multi-edges
// parameters:
//     n         : number of vertices
//     e         : number of edges
// degree distribution:
//     alpha < 1 : P(k) ~ stretched-exponential
//     alpha = 1 : P(k) ~ 1 / k^3 (Barabasi-Albert)
//     alpha > 1 : ~> star-network
{
    
    if(!(n > 1u && exponent > 0.0))
        throw std::runtime_error("invalid parameters in preferentialAttachmentNetwork()");
    
    if(!edges.empty()) edges.clear();
    if(e == 0u) return;
    
    // create initial network
    edges.push_back(Edge {0u, 1u});
    std::vector<size_t> degree(n, 0u);
    degree[0u] = degree[1u] = 1u;
    --e;
    
    // grow network by linking preferentially to well-connected nodes
    std::clog << ':';
    for(size_t i = 2u; i < n && e > 0u; ++i) {
        std::vector<double> w(i);
        for(size_t j = 0u; j < i; ++j) w[j] = pow(degree[j], exponent);
        size_t ki = (i == n - 1u ? e : rnd::binomial(e, 1.0 / (n - i)));
        
        while(ki) {
            // sample neighbours without replacement
            double sumw = 0.0;
            for(size_t j = 0u; j < i; ++j) sumw += w[j];
            if(sumw < 1.0) break;
            std::discrete_distribution<size_t> prob(w.begin(), w.end());
            size_t j = prob(rnd::rng);
            edges.push_back(Edge {i, j});
            w[j] = 0.0;
            ++degree[j];
            ++degree[i];
            --ki;
            --e;
        }
    }
    
    // relabel node indices after sorting with respect to degree
    std::clog << ':';
    std::vector<size_t> rank(n, 0u);
    for(size_t i = 0u; i < n - 1u; ++i) {
        for(size_t j = i + 1u; j < n; ++j)
            if(degree[j] > degree[i]) ++rank[i];
            else ++rank[j];
    }
    for(Edge &edge : edges) {
        edge.first = rank[edge.first];
        edge.second = rank[edge.second];
        if(edge.first > edge.second) std::swap(edge.first, edge.second);
    }
    std::sort(edges.begin(), edges.end(), edgeCompare);
    std::clog << ':';
}

void Individual::generateGeneticArchitecture()
{
    std::clog << "generating a new genetic architecture\n";
    
    // recombination map ***
    std::clog << "  creating recombination map.";
    // chromosomes are identical in size
    for(size_t i = 0u; i < nChromosomes - 1u; ++i)
        chromosomeSize[i] = (i + 1.0) / nChromosomes;
    
    // genes are distributed uniformly across genome
    std::array<double, nLoci> geneLocations;
    for(size_t i = 0u; i < nLoci; ++i)
        geneLocations[i] = rnd::uniform();
    std::sort(geneLocations.begin(), geneLocations.end());
    for(size_t i = 0u, lg = 0u; i < nLoci; ++i) {
        while(lg < nChromosomes - 1u && geneLocations[i] > chromosomeSize[lg]) ++lg;
        characterLocus[i].linkageGroup = lg;
        characterLocus[i].location = geneLocations[i];
    }
    std::clog << "..done\n";
    
    // randomize gene sequence and assign loci to characters
    std::clog << "  assigning loci to characters.";
    std::array<size_t, nLoci> seq;
    for(size_t i = 0u; i < nLoci; ++i) seq[i] = i;
    std::shuffle(seq.begin(), seq.end(), rnd::rng);
    std::array<size_t, nCharacter> nVtx {nEcoLoci, nMatLoci, nNtrLoci};
    for(size_t crctr = 0u, k = 0u; crctr < nCharacter; ++crctr)
        for(size_t j = 0u; j < nVtx[crctr]; ++j, ++k) {
            vertices[crctr].insert(seq[k]);
            characterLocus[seq[k]].character = crctr;
        }
    std::clog << "..done\n";
    
    // sample shared allele effects
    std::array<double, nLoci> sharedAdditiveEffect, sharedInteractionEffect;
    for(size_t i = 0u; i < nLoci; ++i) {
        sharedAdditiveEffect[i] = std::gamma_distribution<double>(alphaAdditiveShared, 1.0)(rnd::rng);
        sharedInteractionEffect[i] = std::gamma_distribution<double>(alphaInteractionShared, 1.0)(rnd::rng);
    }
    
    // assign additive & dominance effects
    std::clog << "  sampling additive and dominance effect.";
    for(size_t crctr = 0u; crctr < nCharacter; ++crctr) {
        double sumaa = 0.0, sumhh = 0.0;
        for(size_t i : vertices[crctr]) {
            characterLocus[i].effectSize = sharedAdditiveEffect[i] +
                std::gamma_distribution<double>(alphaAdditiveRandom, 1.0)(rnd::rng);
            if(rnd::bernoulli(0.5)) characterLocus[i].effectSize *= -1.0;
            sumaa += sqr(characterLocus[i].effectSize);
            characterLocus[i].dominanceCoeff = fabs(rnd::normal(0.0, 1.0));
            sumhh += sqr(characterLocus[i].dominanceCoeff);
        }
        sumaa = sumaa > 0.0 ? sqrt(sumaa) : 1.0;
        sumhh = sumhh > 0.0 ? sqrt(sumhh) : 1.0;
        for(size_t i : vertices[crctr]) {
            characterLocus[i].effectSize /= sumaa;
            characterLocus[i].dominanceCoeff /=sumhh;
        }
    }
    std::clog << "..done\n";
    
    // gene interactions
    std::clog << "  creating gene interaction network.";
    std::array<size_t, nCharacter> nEdg {nEcoInteractions, nMatInteractions, nNtrInteractions};
    for(size_t crctr = 0u, offset = 0u; crctr < nCharacter; ++crctr) {
        std::vector<Edge> edges;
        preferentialAttachmentNetwork(nVtx[crctr], nEdg[crctr], 1.0, edges);
        
        // map network vertices to loci
        double sumww = 0.0;
        for(Edge &edge : edges) {
            size_t i = seq[offset + edge.first];
            size_t j = seq[offset + edge.second];
            if(!(characterLocus[i].character == crctr &&
                 characterLocus[j].character == crctr))
                throw std::logic_error("invalid epistatic interaction in Individual::generateGeneticArchitecture()");
            
            // assign interaction efect size
            double ai = sharedAdditiveEffect[i];
            double aj = sharedAdditiveEffect[j];
            double bi = sharedAdditiveEffect[i];
            double bj = sharedAdditiveEffect[j];
            double wij = (ai + aj > 0.0 ? (ai * aj + ai * bj + aj * bi) / (ai + aj) : 0.0) +
                std::gamma_distribution<double>(alphaInteractionRandom, 1.0)(rnd::rng);
            if(rnd::bernoulli(0.5)) wij *= -1.0;
            characterLocus[i].edges.push_back(std::make_pair(j, wij));
            sumww += wij * wij;
        }
        
        // normalise interaction weights
        sumww = sumww > 0.0 ? sqrt(sumww) : 1.0;
        for(size_t i : vertices[crctr])
            for(std::pair<size_t, double> &edge : characterLocus[i].edges)
                edge.second /= sumww;
    
        offset += nVtx[crctr];
    }
    std::clog << ".done\n";
}

void Individual::loadGeneticArchitecture(const std::string &filename)
{
    std::clog << "loading genetic architecture from file " << filename << '\n';
    
    //open genetic architecture file
    std::ifstream ifs(filename);
    if(!ifs.is_open())
        throw std::runtime_error("unable to open file in loadGeneticArchitecture()");
    
    std::clog << "  validation.";
    
    size_t tmpEcoLoci, tmpMatLoci, tmpNtrLoci, tmpEcoInteractions, tmpMatInteractions, tmpChromosomes;
    ifs >> tmpEcoLoci >> tmpMatLoci >> tmpNtrLoci >> tmpEcoInteractions >> tmpMatInteractions >> tmpChromosomes;
    
    // validation
    if(!(tmpEcoLoci == nEcoLoci && tmpMatLoci == nMatLoci && tmpNtrLoci == nNtrLoci &&
         tmpEcoInteractions == nEcoInteractions && tmpMatInteractions == nMatInteractions &&
         tmpChromosomes == nChromosomes))
        throw std::logic_error("genetic architecture in file is incompatible with current settings in loadGeneticArchitecture()");
    std::clog << "..done\n";
    
    // chromosome sizes
    std::clog << "  loading recombination map.";
    for(double &x : chromosomeSize) ifs >> x;
    std::clog << "..done\n";
    
    std::clog << "  loading locus properties.";
    // gene location, effect size and dominance coefficient
    for(size_t i = 0u, lg = 0u; i < nLoci; ++i) {
        size_t j;
        ifs >> j;
        ifs >> characterLocus[j].character
            >> characterLocus[j].location
            >> characterLocus[j].effectSize
            >> characterLocus[j].dominanceCoeff;
        vertices[characterLocus[j].character].insert(j);
        
        while(lg < nChromosomes - 1u && characterLocus[j].location > chromosomeSize[lg]) ++lg;
        characterLocus[i].linkageGroup = lg;
    }
    std::clog << "..done\n";
    
    // epistatic interactions
    std::clog << "  loading epistatic interactions.";
    size_t i, j;
    double w;
    while(ifs >> i >> j >> w)
        characterLocus[i].edges.push_back(std::make_pair(j, w));
    std::clog << "..done\n";
}

void Individual::storeGeneticArchitecture(const std::string &filename)
{
    //open genetic architecture file
    std::ofstream ofs(filename);
    if(!ofs.is_open())
        throw std::runtime_error("unable to open file in storeGeneticArchitecture()");
    
    ofs << nEcoLoci << '\n'
    << nMatLoci << '\n'
    << nNtrLoci << '\n'
    << nEcoInteractions << '\n'
    << nMatInteractions << '\n'
    << nChromosomes << '\n';
    
    // chromosome sizes
    for(double x : chromosomeSize) ofs << x << '\t';
    ofs << '\n';
    
    // gene location, effect size and dominance coefficient
    for(size_t i = 0u; i < nLoci; ++i)
        ofs << i << '\t'
        << characterLocus[i].character << '\t'
        << characterLocus[i].location << '\t'
        << characterLocus[i].effectSize << '\t'
        << characterLocus[i].dominanceCoeff << '\n';
    
    // epistatic interactions
    for(size_t i = 0u; i < nLoci; ++i)
        for(const std::pair<size_t, double> &edge : characterLocus[i].edges)
            ofs << i << '\t' << edge.first << '\t' << edge.second << '\n';
}



